-- Load the data
c = LOAD("https://raw.githubusercontent.com/acannistra/myria_similarity/master/data/cora/cora.txt",
            csv(schema(unknown:string,
                   pubid:string,
                       author:string,
                       volume:string,
                       title:string,
                       institute:string,
                       venue:string,
                       address:string,
                       pub:string,
                       yr:string, -- "year" is a reserved keyword
                       pages:string,
                       editor:string,
                       note:string,
                       mnth:string, -- "month" is a reserved keyword
                       emptycol:string),
                skip=0, delimiter="\t"));

-- Assign sequential ids
-- Goal: add an integer id to each record. we assume they are unique despite some having the same pubid

APPLY counter() {
-- function from MyriaL language docs
-- WARNING: every partition creates its 
-- own state (i.e. restarts the count) 
  [0 AS c];
  [c + 1];
  c;
};
Cora = [FROM c EMIT counter() as recordid, pubid, author, volume, title, institute, venue, address, pub, yr, pages, editor, note, mnth];
STORE (Cora, Cora);

--------

-- Compute ngrams with n=5
-- Goal: for each record, get ngrams for each field and add them to the table of (recordid, ngram) pairs
Data = scan(Cora);
RelationNgrams = SELECT recordid, ngram(Data.title, 5) as ng FROM Data;
store(RelationNgrams, RelationNgrams);

-- Generate a set of hash functions by defining the coefficients
-- Goal: generate random integer coefficients for a predetermined number of hash functions
MinHashCoefs = load("http://homes.cs.washington.edu/~kdorosch/hash_fns_84.txt", csv(schema(hashFnNo:int, a:int, b:int),
                skip=0, delimiter="\t"));
--STORE(MinHashCoefs, MinHashCoefs);

-- Define the udf for computing a given minhash based on coeffs
def hash(x, a, b): a*x + b;

-- Compute the hash values for all ngrams for all hash functions
-- Goal: each hash function is computed for each ngram with the result stored here.
NgramHashFnMap = [from RelationNgrams r, MinHashCoefs h emit r.ng, r.recordid, h.hashFnNo];
HashesOfNgrams = select n.ng, n.hashFnNo, hash(n.recordid, m.a, m.b) as hashVal
                 from NgramHashFnMap n, MinHashCoefs m
                 where n.hashFnNo = m.hashFnNo;

-- Join the hash computation with the records
-- Goal: each (record, ngram) pair gets matched with its associated hashFnNo and hashVal 
HashesByRecord = SELECT r.recordid, h.ng, h.hashFnNo, h.hashVal 
                 FROM RelationNgrams r, HashesOfNgrams h
                 WHERE r.ng = h.ng;
                 
-- Compute the MinHash signature matrix.
-- Goal: find the minimum value produced by any hash for a given ngram of a given record.
--       In other words, find (recordid, hashFnNo) pairs with the lowest hashVal
SignatureMatrix = [from HashesByRecord 
                   emit recordid, hashFnNo, min(hashVal) as minHashVal];
--STORE(SignatureMatrix, SignatureMatrix);

-- Compute the LSH matrix 
-- Goal: partition the signature matrix into m groups of k hash functions (l=84, m=16, k=4)

def mod(x, n): x - int(x/n)*n;

def lsh_mod(x, nbins): mod(x, nbins);


-- Add band numbers
-- Goal: Compute which band each hash function belongs to by taking the mod of the hashFnNo
-- TODO: REMOVE LITERAL 16
m = [16];
BandedSigMatrix = select sm.recordid, mod(sm.hashFnNo, *m) as bandNo, sm.hashFnNo, sm.minHashVal 
                  from SignatureMatrix sm;

--STORE(BandedSigMatrix, BandedSigMatrix);


BandedSigMatrix = scan(BandedSigMatrix);
LSH_temp = [from BandedSigMatrix bsm emit bsm.recordid, bsm.bandNo, lsh_mod(sum(bsm.minHashVal), 1000) as lsh];

LSHMatrix = select bsm.recordid, bsm.bandNo, bsm.hashFnNo, bsm.minHashVal, lsht.lsh 
            from LSH_temp lsht, BandedSigMatrix bsm 
            where bsm.recordid=lsht.recordid and bsm.bandNo = lsht.bandNo;

--store(LSHMatrix, LSHMatrix, [lsh]);

------------------------------------
--LSHMatrix = scan(LSHMatrix);
-- Have LSHMatrix: recordid, bandNo, hashFnNo, minHashVal, lsh
-- Goal: intersection of ngrams by bucket
-- from lsh lsh RelationNgrams where a.rid = r1.rid, b.rid = r2.rid, ngrams are same, lsh = lsh emit r1.rid, r2.rid, count(*) as inter]
intersection = [from LSHMatrix a, LSHMatrix b, RelationNgrams ra, RelationNgrams rb
                where a.lsh = b.lsh
                  and a.recordid = ra.recordid
                  and b.recordid = rb.recordid
                  and ra.ng = rb.ng
                emit ra.recordid as rid1, rb.recordid as rid2, a.lsh, count(*) as inter];

--store(intersection, intersection);

-- count unique ngrams within a record
distinctNgrams = select distinct recordid, ng from RelationNgrams;
ngramSetSizes = select recordid, count(ng) as cnt from distinctNgrams;

-- compute jaccard within buckets
def jaccard(a, b, inter): inter / ((a-b)-inter); -- set difference
jac = select i.rid1, i.rid2, jaccard(na.cnt, nb.cnt, i.inter) as sim, i.lsh
      from intersection i, ngramSetSizes na, ngramSetSizes nb
      where i.rid1 = na.recordid
        and i.rid2 = nb.recordid;
store(jac, jac);

--   

-- wrong
--groups = select lsma.recordid, lsmb.recordid, count(*) from LSHMatrix lsma, LSHMatrix lsmb where lsma.lsh=lsmb.lsh and lsma.hashFnNo = lsmb.hashFnNo and lsma.minHashVal=lsmb.minHashVal;

--store(groups, groups);

